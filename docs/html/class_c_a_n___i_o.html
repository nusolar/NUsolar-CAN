<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NUsolar CAN: CAN_IO Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NUsolar CAN
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_c_a_n___i_o-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CAN_IO Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for handling CAN I/O operations using the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> CAN controller.  
 <a href="class_c_a_n___i_o.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_c_a_n___i_o_8h_source.html">CAN_IO.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a54219933510b3a5fd23aa0e12fda9f90"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#a54219933510b3a5fd23aa0e12fda9f90">CAN_IO</a> (byte CS_pin, byte INT_pin, int baud, byte freq)</td></tr>
<tr class="memdesc:a54219933510b3a5fd23aa0e12fda9f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a54219933510b3a5fd23aa0e12fda9f90">More...</a><br /></td></tr>
<tr class="separator:a54219933510b3a5fd23aa0e12fda9f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8658429bfd9b825a1e1758514ed387eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#a8658429bfd9b825a1e1758514ed387eb">Setup</a> (byte interrupts=<a class="el" href="_m_c_p2515__defs_8h.html#a6978bfe6ae8159fa041a4c388c9978a0">RX0IE</a>|<a class="el" href="_m_c_p2515__defs_8h.html#a4a83bd5cc435fc9953e5f2ac7d5215ed">RX1IE</a>|<a class="el" href="_m_c_p2515__defs_8h.html#af887675075169f716f45e1266b36beb7">TX1IE</a>|<a class="el" href="_m_c_p2515__defs_8h.html#a7f4fd75676158acd6567364d981a16f3">TX2IE</a>|<a class="el" href="_m_c_p2515__defs_8h.html#a46a0a594d03278b315e6b1a173b9967b">TX0IE</a>)</td></tr>
<tr class="memdesc:a8658429bfd9b825a1e1758514ed387eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method for the can controller.  <a href="#a8658429bfd9b825a1e1758514ed387eb">More...</a><br /></td></tr>
<tr class="separator:a8658429bfd9b825a1e1758514ed387eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cc76436585581d1d449f806bd69c51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#a04cc76436585581d1d449f806bd69c51">Sleep</a> ()</td></tr>
<tr class="memdesc:a04cc76436585581d1d449f806bd69c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the controller to sleep. See the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> datasheet.  <a href="#a04cc76436585581d1d449f806bd69c51">More...</a><br /></td></tr>
<tr class="separator:a04cc76436585581d1d449f806bd69c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e9bf23190283eb015b24f2d78ba413"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#a40e9bf23190283eb015b24f2d78ba413">Wake</a> ()</td></tr>
<tr class="memdesc:a40e9bf23190283eb015b24f2d78ba413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wake the controller up from sleep. See the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> datasheet.  <a href="#a40e9bf23190283eb015b24f2d78ba413">More...</a><br /></td></tr>
<tr class="separator:a40e9bf23190283eb015b24f2d78ba413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359a9994e7068dc3a33462d26f015ce5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#a359a9994e7068dc3a33462d26f015ce5">ResetController</a> ()</td></tr>
<tr class="memdesc:a359a9994e7068dc3a33462d26f015ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitialize the controller by calling <a class="el" href="class_m_c_p2515.html#a54c16cbee2cace366fef4bdcfdf245a6" title="Initialization function. ">MCP2515::Init()</a> again.  <a href="#a359a9994e7068dc3a33462d26f015ce5">More...</a><br /></td></tr>
<tr class="separator:a359a9994e7068dc3a33462d26f015ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17eb672ec9cadd64aeacaa9042646413"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#a17eb672ec9cadd64aeacaa9042646413">ConfigureInterrupts</a> (byte interrupts)</td></tr>
<tr class="memdesc:a17eb672ec9cadd64aeacaa9042646413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconfigure the interrupts that are enabled on the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a>.  <a href="#a17eb672ec9cadd64aeacaa9042646413">More...</a><br /></td></tr>
<tr class="separator:a17eb672ec9cadd64aeacaa9042646413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533d98d764de7d4b5805c81259b1ffd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#a533d98d764de7d4b5805c81259b1ffd6">setAutoFetch</a> (bool set)</td></tr>
<tr class="memdesc:a533d98d764de7d4b5805c81259b1ffd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggles AutoFetch on and off.  <a href="#a533d98d764de7d4b5805c81259b1ffd6">More...</a><br /></td></tr>
<tr class="separator:a533d98d764de7d4b5805c81259b1ffd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02724e01fa0b5d3bd6d50e00f5b4f523"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#a02724e01fa0b5d3bd6d50e00f5b4f523">Fetch</a> ()</td></tr>
<tr class="memdesc:a02724e01fa0b5d3bd6d50e00f5b4f523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch any available messages from the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a>.  <a href="#a02724e01fa0b5d3bd6d50e00f5b4f523">More...</a><br /></td></tr>
<tr class="separator:a02724e01fa0b5d3bd6d50e00f5b4f523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10393f1a9f55c853bb21d74ebbc9d7ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#a10393f1a9f55c853bb21d74ebbc9d7ca">FetchErrors</a> ()</td></tr>
<tr class="memdesc:a10393f1a9f55c853bb21d74ebbc9d7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the error status of the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> over SPI and update internal variables.  <a href="#a10393f1a9f55c853bb21d74ebbc9d7ca">More...</a><br /></td></tr>
<tr class="separator:a10393f1a9f55c853bb21d74ebbc9d7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab012915eb2b8e73476ec16f97c5edb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#aab012915eb2b8e73476ec16f97c5edb5">FetchStatus</a> ()</td></tr>
<tr class="memdesc:aab012915eb2b8e73476ec16f97c5edb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the contents of <a class="el" href="_m_c_p2515__defs_8h.html#a6a94773afc5cf8a9065d3588dccc42be">CANSTAT</a> register.  <a href="#aab012915eb2b8e73476ec16f97c5edb5">More...</a><br /></td></tr>
<tr class="separator:aab012915eb2b8e73476ec16f97c5edb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e0198aa24bd6125e0a5f0598bb33d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#a71e0198aa24bd6125e0a5f0598bb33d5">Send</a> (const <a class="el" href="class_layout.html">Layout</a> &amp;layout, uint8_t buffer)</td></tr>
<tr class="memdesc:a71e0198aa24bd6125e0a5f0598bb33d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to the CAN bus via the controller.  <a href="#a71e0198aa24bd6125e0a5f0598bb33d5">More...</a><br /></td></tr>
<tr class="separator:a71e0198aa24bd6125e0a5f0598bb33d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa513fd1e7bde744c3ef7f9fcbbbe573"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#aaa513fd1e7bde744c3ef7f9fcbbbe573">Send</a> (const <a class="el" href="struct_frame.html">Frame</a> &amp;frame, uint8_t buffer)</td></tr>
<tr class="memdesc:aaa513fd1e7bde744c3ef7f9fcbbbe573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to the CAN bus via the controller.  <a href="#aaa513fd1e7bde744c3ef7f9fcbbbe573">More...</a><br /></td></tr>
<tr class="separator:aaa513fd1e7bde744c3ef7f9fcbbbe573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666bb97e677c178a8345fb11c5400e62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#a666bb97e677c178a8345fb11c5400e62">SendVerified</a> (const <a class="el" href="class_layout.html">Layout</a> &amp;layout, uint8_t buffer)</td></tr>
<tr class="memdesc:a666bb97e677c178a8345fb11c5400e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to the CAN bus via the controller, confirming correct SPI transmission.  <a href="#a666bb97e677c178a8345fb11c5400e62">More...</a><br /></td></tr>
<tr class="separator:a666bb97e677c178a8345fb11c5400e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71af5c6b8cc3b9d9f7097f0ddd1c517"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#ad71af5c6b8cc3b9d9f7097f0ddd1c517">SendVerified</a> (const <a class="el" href="struct_frame.html">Frame</a> &amp;frame, uint8_t buffer)</td></tr>
<tr class="memdesc:ad71af5c6b8cc3b9d9f7097f0ddd1c517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to the CAN bus via the controller, confirming correct SPI transmission.  <a href="#ad71af5c6b8cc3b9d9f7097f0ddd1c517">More...</a><br /></td></tr>
<tr class="separator:ad71af5c6b8cc3b9d9f7097f0ddd1c517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddc5defd3b2f0a865ae3f2d050045a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_frame.html">Frame</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#a4ddc5defd3b2f0a865ae3f2d050045a3">Read</a> ()</td></tr>
<tr class="memdesc:a4ddc5defd3b2f0a865ae3f2d050045a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next packet received from the CAN bus.  <a href="#a4ddc5defd3b2f0a865ae3f2d050045a3">More...</a><br /></td></tr>
<tr class="separator:a4ddc5defd3b2f0a865ae3f2d050045a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e020109c1da977940fbce0d314bb47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#a33e020109c1da977940fbce0d314bb47">Available</a> ()</td></tr>
<tr class="memdesc:a33e020109c1da977940fbce0d314bb47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if any incoming CAN packets are available.  <a href="#a33e020109c1da977940fbce0d314bb47">More...</a><br /></td></tr>
<tr class="separator:a33e020109c1da977940fbce0d314bb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a639b6c622d0ed337ef26c0fe086e6553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_c_p2515.html">MCP2515</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#a639b6c622d0ed337ef26c0fe086e6553">controller</a></td></tr>
<tr class="memdesc:a639b6c622d0ed337ef26c0fe086e6553"><td class="mdescLeft">&#160;</td><td class="mdescRight">An instance of the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> class allowing easy access of <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> functions over SPI.  <a href="#a639b6c622d0ed337ef26c0fe086e6553">More...</a><br /></td></tr>
<tr class="separator:a639b6c622d0ed337ef26c0fe086e6553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f603bf473485c7231b30d99e0b848b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_x___queue.html">RX_Queue</a>&lt; 16 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#a84f603bf473485c7231b30d99e0b848b">RXbuffer</a></td></tr>
<tr class="memdesc:a84f603bf473485c7231b30d99e0b848b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A local queue for holding incoming message frames as they are retreived by the Fetch function. Can hold up to 16 frames at a time.  <a href="#a84f603bf473485c7231b30d99e0b848b">More...</a><br /></td></tr>
<tr class="separator:a84f603bf473485c7231b30d99e0b848b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0060e57a9c6cff0e58451a32e211fe"><td class="memItemLeft" align="right" valign="top">volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#a6f0060e57a9c6cff0e58451a32e211fe">canstat_register</a></td></tr>
<tr class="memdesc:a6f0060e57a9c6cff0e58451a32e211fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a copy of the <a class="el" href="_m_c_p2515__defs_8h.html#a6a94773afc5cf8a9065d3588dccc42be">CANSTAT</a> register.  <a href="#a6f0060e57a9c6cff0e58451a32e211fe">More...</a><br /></td></tr>
<tr class="separator:a6f0060e57a9c6cff0e58451a32e211fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb95e1f49ff76257712e931be5634e25"><td class="memItemLeft" align="right" valign="top">volatile uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#abb95e1f49ff76257712e931be5634e25">errors</a></td></tr>
<tr class="memdesc:abb95e1f49ff76257712e931be5634e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitmap of the errors on the CAN bus.  <a href="#abb95e1f49ff76257712e931be5634e25">More...</a><br /></td></tr>
<tr class="separator:abb95e1f49ff76257712e931be5634e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bb474f87b56bf6aec097c8a7760a40"><td class="memItemLeft" align="right" valign="top">volatile uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#a70bb474f87b56bf6aec097c8a7760a40">tec</a></td></tr>
<tr class="memdesc:a70bb474f87b56bf6aec097c8a7760a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmission Error Counter.  <a href="#a70bb474f87b56bf6aec097c8a7760a40">More...</a><br /></td></tr>
<tr class="separator:a70bb474f87b56bf6aec097c8a7760a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaeb025fc077395159d3a8850205f021"><td class="memItemLeft" align="right" valign="top">volatile uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#acaeb025fc077395159d3a8850205f021">rec</a></td></tr>
<tr class="memdesc:acaeb025fc077395159d3a8850205f021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive Error Counter.  <a href="#acaeb025fc077395159d3a8850205f021">More...</a><br /></td></tr>
<tr class="separator:acaeb025fc077395159d3a8850205f021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572920279e459c42750d14a251c41944"><td class="memItemLeft" align="right" valign="top">volatile long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#a572920279e459c42750d14a251c41944">int_counter</a></td></tr>
<tr class="memdesc:a572920279e459c42750d14a251c41944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments every time an interrupt from the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> comes in.  <a href="#a572920279e459c42750d14a251c41944">More...</a><br /></td></tr>
<tr class="separator:a572920279e459c42750d14a251c41944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd473b4b58e8ff57f54753729905bd4a"><td class="memItemLeft" align="right" valign="top">volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#afd473b4b58e8ff57f54753729905bd4a">last_interrupt</a></td></tr>
<tr class="memdesc:afd473b4b58e8ff57f54753729905bd4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the return value of GetInterrupt() every time <a class="el" href="class_c_a_n___i_o.html#a02724e01fa0b5d3bd6d50e00f5b4f523" title="Fetch any available messages from the MCP2515. ">Fetch()</a> is called.  <a href="#afd473b4b58e8ff57f54753729905bd4a">More...</a><br /></td></tr>
<tr class="separator:afd473b4b58e8ff57f54753729905bd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f3b7f300b3b9879fd596c1be42999a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_a_n_filter_opt.html">CANFilterOpt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_a_n___i_o.html#a49f3b7f300b3b9879fd596c1be42999a">filters</a></td></tr>
<tr class="memdesc:a49f3b7f300b3b9879fd596c1be42999a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the filters currently in use by the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a>.  <a href="#a49f3b7f300b3b9879fd596c1be42999a">More...</a><br /></td></tr>
<tr class="separator:a49f3b7f300b3b9879fd596c1be42999a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for handling CAN I/O operations using the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> CAN controller. </p>
<p>You must create an instance of this object within your Arduino <a class="el" href="class_c_a_n___i_o.html#a8658429bfd9b825a1e1758514ed387eb" title="Initialization method for the can controller. ">Setup()</a> function, and then call its <a class="el" href="class_c_a_n___i_o.html#a8658429bfd9b825a1e1758514ed387eb">Setup()</a> function to initialize the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> controller to the proper settings. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a54219933510b3a5fd23aa0e12fda9f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54219933510b3a5fd23aa0e12fda9f90">&#9670;&nbsp;</a></span>CAN_IO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CAN_IO::CAN_IO </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>CS_pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>INT_pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>freq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CS_pin</td><td>The arduino pin # to which the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> chip select pin is attached. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">INT_pin</td><td>The arduino pin # to which the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> interrupt pin is attached. This should be specified even if AutoFetch is disabled, as the <a class="el" href="class_c_a_n___i_o.html#a02724e01fa0b5d3bd6d50e00f5b4f523" title="Fetch any available messages from the MCP2515. ">CAN_IO::Fetch()</a> routine uses this pin to check whether there are incoming messages.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baud</td><td>Baud rate of the CAN bus, in kbps. SC6 runs at 1mbps, or baud = 1000. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>Frequency of the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> external resonator, in Mhz. For NUsolar boards on SC6, this is 16Mhz or freq = 16. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a33e020109c1da977940fbce0d314bb47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e020109c1da977940fbce0d314bb47">&#9670;&nbsp;</a></span>Available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CAN_IO::Available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if any incoming CAN packets are available. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the internal <a class="el" href="class_r_x___queue.html" title="Static receiving deque for CAN_IO class. ">RX_Queue</a> which holds incoming packets is not empty. </dd></dl>

</div>
</div>
<a id="a17eb672ec9cadd64aeacaa9042646413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17eb672ec9cadd64aeacaa9042646413">&#9670;&nbsp;</a></span>ConfigureInterrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CAN_IO::ConfigureInterrupts </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>interrupts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reconfigure the interrupts that are enabled on the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interrupts</td><td>Binary interrupt enable flags (see <a class="el" href="class_c_a_n___i_o.html#a8658429bfd9b825a1e1758514ed387eb" title="Initialization method for the can controller. ">CAN_IO::Setup()</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful </dd></dl>

</div>
</div>
<a id="a02724e01fa0b5d3bd6d50e00f5b4f523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02724e01fa0b5d3bd6d50e00f5b4f523">&#9670;&nbsp;</a></span>Fetch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CAN_IO::Fetch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch any available messages from the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a>. </p>
<p>Reads messages from the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> over SPI and stores them in the internal <a class="el" href="class_r_x___queue.html" title="Static receiving deque for CAN_IO class. ">RX_Queue</a> buffer as <a class="el" href="struct_frame.html" title="An object representing a generic CAN frame. ">Frame</a> objects until the user calls <a class="el" href="class_c_a_n___i_o.html#a4ddc5defd3b2f0a865ae3f2d050045a3" title="Reads the next packet received from the CAN bus. ">CAN_IO::Read()</a>.</p>
<p>This method checks and stash them in a local <a class="el" href="class_r_x___queue.html" title="Static receiving deque for CAN_IO class. ">RX_Queue</a> object so that the user can later read the data using the <a class="el" href="class_c_a_n___i_o.html#a4ddc5defd3b2f0a865ae3f2d050045a3" title="Reads the next packet received from the CAN bus. ">CAN_IO::Read()</a> function. </p>
<p>Comment out the first line of this function if not using the <a class="el" href="class_c_a_n___i_o.html#a8658429bfd9b825a1e1758514ed387eb">RX0IE and RX1IE interrupt enable flags</a>. </p>

</div>
</div>
<a id="a10393f1a9f55c853bb21d74ebbc9d7ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10393f1a9f55c853bb21d74ebbc9d7ca">&#9670;&nbsp;</a></span>FetchErrors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CAN_IO::FetchErrors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the error status of the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> over SPI and update internal variables. </p>
<p>Makes reads the contents of the TEC, REC, and EFLG registers on the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a>.</p>
<p>TEC and REC each represent an integer count of the number of transmission and receive errors and get stored directly in the tec and rec local variables.</p>
<p>EFLG is used to set the appropriate error flags in the local errors variable. </p>

</div>
</div>
<a id="aab012915eb2b8e73476ec16f97c5edb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab012915eb2b8e73476ec16f97c5edb5">&#9670;&nbsp;</a></span>FetchStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CAN_IO::FetchStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the contents of <a class="el" href="_m_c_p2515__defs_8h.html#a6a94773afc5cf8a9065d3588dccc42be">CANSTAT</a> register. </p>
<p>A copy of the register is storred in canstat_register. This can be used to determine</p><ul>
<li>The current mode of the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a></li>
<li></li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Finish documenting <a class="el" href="_m_c_p2515__defs_8h.html#a6a94773afc5cf8a9065d3588dccc42be">CANSTAT</a> register. </dd></dl>

</div>
</div>
<a id="a4ddc5defd3b2f0a865ae3f2d050045a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddc5defd3b2f0a865ae3f2d050045a3">&#9670;&nbsp;</a></span>Read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_frame.html">Frame</a>&amp; CAN_IO::Read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the next packet received from the CAN bus. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_frame.html" title="An object representing a generic CAN frame. ">Frame</a>&amp; object which can be used to access the next object in the internal <a class="el" href="class_r_x___queue.html" title="Static receiving deque for CAN_IO class. ">RX_Queue</a>. </dd></dl>

</div>
</div>
<a id="a359a9994e7068dc3a33462d26f015ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359a9994e7068dc3a33462d26f015ce5">&#9670;&nbsp;</a></span>ResetController()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CAN_IO::ResetController </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reinitialize the controller by calling <a class="el" href="class_m_c_p2515.html#a54c16cbee2cace366fef4bdcfdf245a6" title="Initialization function. ">MCP2515::Init()</a> again. </p>

</div>
</div>
<a id="a71e0198aa24bd6125e0a5f0598bb33d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e0198aa24bd6125e0a5f0598bb33d5">&#9670;&nbsp;</a></span>Send() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CAN_IO::Send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_layout.html">Layout</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends messages to the CAN bus via the controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Constant reference to a <a class="el" href="class_layout.html" title="Abstract Layout Packet Base Class. ">Layout</a> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Specify the transmit buffer to use on the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a>. Possible values are: TXB0, TXB1, TXB2, TXBANY (i.e. automatically chosen) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful</dd></dl>
<p>Sample sending a <a class="el" href="class_d_c___heartbeat.html" title="Driver controls heartbeat packet. ">DC_Heartbeat</a> packet using a right-hand constant reference through any TX buffer: </p><div class="fragment"><div class="line"><a class="code" href="class_c_a_n___i_o.html#a71e0198aa24bd6125e0a5f0598bb33d5">CAN_IO::Send</a>(<a class="code" href="class_d_c___heartbeat.html">DC_Heartbeat</a>(0x1234,0x5678), TXANY); </div></div><!-- fragment --><p>Sample sending a <a class="el" href="class_d_c___heartbeat.html" title="Driver controls heartbeat packet. ">DC_Heartbeat</a> packet using a standard object reference through any TX buffer: </p><div class="fragment"><div class="line"><a class="code" href="class_d_c___heartbeat.html">DC_Heartbeat</a> p = <a class="code" href="class_d_c___heartbeat.html">DC_Heartbeat</a>(0x1234,0x5678); <a class="code" href="class_c_a_n___i_o.html#a71e0198aa24bd6125e0a5f0598bb33d5">CAN_IO::Send</a>(p, TXANY); </div></div><!-- fragment --> 
</div>
</div>
<a id="aaa513fd1e7bde744c3ef7f9fcbbbe573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa513fd1e7bde744c3ef7f9fcbbbe573">&#9670;&nbsp;</a></span>Send() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CAN_IO::Send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_frame.html">Frame</a> &amp;&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends messages to the CAN bus via the controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frame</td><td>Constant reference to a <a class="el" href="struct_frame.html" title="An object representing a generic CAN frame. ">Frame</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Specify the transmit buffer to use on the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a>. Possible values are: TXB0, TXB1, TXB2, TXBANY (i.e. automatically chosen) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful</dd></dl>
<p>Similar to the Layout-based send function but accepts <a class="el" href="struct_frame.html" title="An object representing a generic CAN frame. ">Frame</a> object instead. </p>

</div>
</div>
<a id="a666bb97e677c178a8345fb11c5400e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666bb97e677c178a8345fb11c5400e62">&#9670;&nbsp;</a></span>SendVerified() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CAN_IO::SendVerified </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_layout.html">Layout</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends messages to the CAN bus via the controller, confirming correct SPI transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Constant reference to a <a class="el" href="class_layout.html" title="Abstract Layout Packet Base Class. ">Layout</a> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Specify the transmit buffer to use on the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a>. Possible values are: TXB0, TXB1, TXB2, TXBANY (i.e. automatically chosen) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful</dd></dl>
<p>Same usage as the corresponding <a class="el" href="class_c_a_n___i_o.html#a71e0198aa24bd6125e0a5f0598bb33d5" title="Sends messages to the CAN bus via the controller. ">Send()</a> function. However, after loading a message into the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> TX buffers, this function reads the loaded message back to confirm that it is not corrupted. </p>

</div>
</div>
<a id="ad71af5c6b8cc3b9d9f7097f0ddd1c517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad71af5c6b8cc3b9d9f7097f0ddd1c517">&#9670;&nbsp;</a></span>SendVerified() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CAN_IO::SendVerified </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_frame.html">Frame</a> &amp;&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends messages to the CAN bus via the controller, confirming correct SPI transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frame</td><td>Constant reference to a <a class="el" href="struct_frame.html" title="An object representing a generic CAN frame. ">Frame</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Specify the transmit buffer to use on the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a>. Possible values are: TXB0, TXB1, TXB2, TXBANY (i.e. automatically chosen) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful</dd></dl>
<p>Same usage as the corresponding <a class="el" href="class_c_a_n___i_o.html#a71e0198aa24bd6125e0a5f0598bb33d5" title="Sends messages to the CAN bus via the controller. ">Send()</a> function. However, after loading a message into the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> TX buffers, this function reads the loaded message back to confirm that it is not corrupted. </p>

</div>
</div>
<a id="a533d98d764de7d4b5805c81259b1ffd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533d98d764de7d4b5805c81259b1ffd6">&#9670;&nbsp;</a></span>setAutoFetch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CAN_IO::setAutoFetch </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Toggles AutoFetch on and off. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">set</td><td>true = attach interrupt pin to the CAN_ISR routine, false = detatch interrupt from the interrupt pin [default]</td></tr>
  </table>
  </dd>
</dl>
<p>AutoFetch is off by default because the interrupt feature it uses causes problems when running at the same time as SPI. We were observing corrupted CAN packets being sent when AutoFetch was enabled. </p>

</div>
</div>
<a id="a8658429bfd9b825a1e1758514ed387eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8658429bfd9b825a1e1758514ed387eb">&#9670;&nbsp;</a></span>Setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CAN_IO::Setup </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>interrupts</em> = <code><a class="el" href="_m_c_p2515__defs_8h.html#a6978bfe6ae8159fa041a4c388c9978a0">RX0IE</a>&#160;|&#160;<a class="el" href="_m_c_p2515__defs_8h.html#a4a83bd5cc435fc9953e5f2ac7d5215ed">RX1IE</a>&#160;|&#160;<a class="el" href="_m_c_p2515__defs_8h.html#af887675075169f716f45e1266b36beb7">TX1IE</a>&#160;|&#160;<a class="el" href="_m_c_p2515__defs_8h.html#a7f4fd75676158acd6567364d981a16f3">TX2IE</a>&#160;|&#160;<a class="el" href="_m_c_p2515__defs_8h.html#a46a0a594d03278b315e6b1a173b9967b">TX0IE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization method for the can controller. </p>
<p>Initializes the CAN controller to desired settings, including read masks/filters. All types of interrupt are enabled by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interrupts</td><td>Binary interrupt enable flags. The flags can be combined by ORing them together using the | operator. By default, the following interrupts are enabled: RX0IE, RX1IE, TX0IE, TX1IE, TX2IE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04cc76436585581d1d449f806bd69c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04cc76436585581d1d449f806bd69c51">&#9670;&nbsp;</a></span>Sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CAN_IO::Sleep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the controller to sleep. See the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> datasheet. </p>

</div>
</div>
<a id="a40e9bf23190283eb015b24f2d78ba413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e9bf23190283eb015b24f2d78ba413">&#9670;&nbsp;</a></span>Wake()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CAN_IO::Wake </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wake the controller up from sleep. See the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> datasheet. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6f0060e57a9c6cff0e58451a32e211fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0060e57a9c6cff0e58451a32e211fe">&#9670;&nbsp;</a></span>canstat_register</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint8_t CAN_IO::canstat_register</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Holds a copy of the <a class="el" href="_m_c_p2515__defs_8h.html#a6a94773afc5cf8a9065d3588dccc42be">CANSTAT</a> register. </p>
<p>Updated when <a class="el" href="class_c_a_n___i_o.html#a10393f1a9f55c853bb21d74ebbc9d7ca" title="Fetch the error status of the MCP2515 over SPI and update internal variables. ">FetchErrors()</a> is called. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>Rename this to be consistent with the errors variable. </dd></dl>

</div>
</div>
<a id="a639b6c622d0ed337ef26c0fe086e6553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a639b6c622d0ed337ef26c0fe086e6553">&#9670;&nbsp;</a></span>controller</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_c_p2515.html">MCP2515</a> CAN_IO::controller</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An instance of the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> class allowing easy access of <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> functions over SPI. </p>

</div>
</div>
<a id="abb95e1f49ff76257712e931be5634e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb95e1f49ff76257712e931be5634e25">&#9670;&nbsp;</a></span>errors</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint32_t CAN_IO::errors</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitmap of the errors on the CAN bus. </p>
<p>Bits correspond to the <a class="el" href="group___c_a_n_e_r_r_o_r_s___g_r_o_u_p.html">Standard CAN errors</a>. Updated when <a class="el" href="class_c_a_n___i_o.html#a10393f1a9f55c853bb21d74ebbc9d7ca" title="Fetch the error status of the MCP2515 over SPI and update internal variables. ">FetchErrors()</a> is called. </p>

</div>
</div>
<a id="a49f3b7f300b3b9879fd596c1be42999a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f3b7f300b3b9879fd596c1be42999a">&#9670;&nbsp;</a></span>filters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_a_n_filter_opt.html">CANFilterOpt</a> CAN_IO::filters</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the filters currently in use by the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a>. </p>

</div>
</div>
<a id="a572920279e459c42750d14a251c41944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572920279e459c42750d14a251c41944">&#9670;&nbsp;</a></span>int_counter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile long CAN_IO::int_counter</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments every time an interrupt from the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> comes in. </p>
<p>Does nothing when AutoFetch is disabled (default behavior). </p>

</div>
</div>
<a id="afd473b4b58e8ff57f54753729905bd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd473b4b58e8ff57f54753729905bd4a">&#9670;&nbsp;</a></span>last_interrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint8_t CAN_IO::last_interrupt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the return value of GetInterrupt() every time <a class="el" href="class_c_a_n___i_o.html#a02724e01fa0b5d3bd6d50e00f5b4f523" title="Fetch any available messages from the MCP2515. ">Fetch()</a> is called. </p>
<p>This allows the user to see what the interrupt status was even after <a class="el" href="class_c_a_n___i_o.html#a02724e01fa0b5d3bd6d50e00f5b4f523" title="Fetch any available messages from the MCP2515. ">Fetch()</a> clears the register </p>

</div>
</div>
<a id="acaeb025fc077395159d3a8850205f021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaeb025fc077395159d3a8850205f021">&#9670;&nbsp;</a></span>rec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint32_t CAN_IO::rec</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive Error Counter. </p>
<p>Integer value corresponding to the # of message errors (when receiving). The <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> goes into BUS PASSIVE mode when this value exceeds 127, and goes into BUS OFF mode when it exceeds 255. </p>

</div>
</div>
<a id="a84f603bf473485c7231b30d99e0b848b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f603bf473485c7231b30d99e0b848b">&#9670;&nbsp;</a></span>RXbuffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_x___queue.html">RX_Queue</a>&lt;16&gt; CAN_IO::RXbuffer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A local queue for holding incoming message frames as they are retreived by the Fetch function. Can hold up to 16 frames at a time. </p>

</div>
</div>
<a id="a70bb474f87b56bf6aec097c8a7760a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70bb474f87b56bf6aec097c8a7760a40">&#9670;&nbsp;</a></span>tec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint32_t CAN_IO::tec</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmission Error Counter. </p>
<p>Integer value corresponding to the # of failed transmission attempts. The <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> goes into BUS PASSIVE mode when this value exceeds 127, and goes into BUS OFF mode when it exceeds 255. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_c_a_n___i_o_8h_source.html">CAN_IO.h</a></li>
<li><a class="el" href="_c_a_n___i_o_8cpp.html">CAN_IO.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
