<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NUsolar CAN: NUsolar MCP2515 CAN Library for Arduino</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NUsolar CAN
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">NUsolar <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> CAN Library for Arduino </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Author: Alexander Martin</p>
<p>Date Last Revised: 6/13/2015</p>
<p>Library Version: 3.0</p>
<p>Full Documentation: <a href="https://nusolar.github.io/NUsolar-CAN/docs/html/index.html">https://nusolar.github.io/NUsolar-CAN/docs/html/index.html</a></p>
<h2>Goals </h2>
<p>This library is intended to simplify CAN bus communication for Arduino MCUs in NUsolar's vehicles which use the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a>. The library encapsulates the entire sending procedure into a single fuction call, and adds a buffer for holding incoming messages. It also defines a large number of packet layouts as classes, which allow data to easily be place into the CAN frame format.</p>
<h2>Installation &ndash; Zip File </h2>
<p>To use the library, simply download the zip file of this repository from github and use the library manager inside Aruduino to load the library into the Arduino IDE.</p>
<h2>Installation &ndash; Cloning </h2>
<p>If you want to be able to use the library as well as push changes to it, you need to CLONE the git repository into your Arduino Libraries folder. This is typically located in C:/Users/YourUsername/Documents/Arduino/libraries. You should clone the SC7-can repo into this folder, so that the structure looks like: .../Documents/Arduino/libraries/sc7-can/</p>
<p>Once this is done, restart arduino and the NUsolar CAN library should show up under the "Sketch-&gt;Include Libraries" menu.</p>
<p>For more information on installing libraries, visit <a href="http://www.arduino.cc/en/Guide/Libraries">http://www.arduino.cc/en/Guide/Libraries</a>.</p>
<h2>Usage </h2>
<ol type="1">
<li>Create a <a class="el" href="class_c_a_n___i_o.html" title="Class for handling CAN I/O operations using the MCP2515 CAN controller. ">CAN_IO</a> object, specifying the pins that will be used as the CS and INT pins <div class="fragment"><div class="line"><a class="code" href="class_c_a_n___i_o.html">CAN_IO</a> can( CSpin, INTpin, baudrate (kbps), freq. Osc. (Mhz));</div></div><!-- fragment --></li>
<li>Setupt filters by calling the setRB&lt;n&gt; methods of the built-in filters object. These methods return their calling object, so they can be daisy-chained, as shown below. <div class="fragment"><div class="line">can.filters.setRB0(m0, f0, f1).setRB1(m1, f2, f3, f4, f5);</div></div><!-- fragment --> to configure the masks and filters for the two receive buffers on the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a>.</li>
<li>Call <code><a class="el" href="class_c_a_n___i_o.html#a8658429bfd9b825a1e1758514ed387eb" title="Initialization method for the can controller. ">CAN_IO::Setup</a>(&lt;interrupts&gt;)</code> to initialize the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a>. <code>&lt;interrupts&gt;</code> is a byte containing the interrupt enable flags that you want to set (i.e. MERRIE, ERRIE, RX0IE, etc.) You can OR these flags together to combine them. For example, the following code enables the Message Receive Error, Generic Error, Receive Buffer 0, and Receive Buffer 1 interrupts. <div class="fragment"><div class="line">can.Setup(MERRIE|<a class="code" href="_m_c_p2515__defs_8h.html#a2e06257308190ec132aa0930f80fe0c9">ERRIE</a>|<a class="code" href="_m_c_p2515__defs_8h.html#a6978bfe6ae8159fa041a4c388c9978a0">RX0IE</a>|<a class="code" href="_m_c_p2515__defs_8h.html#a4a83bd5cc435fc9953e5f2ac7d5215ed">RX1IE</a>);</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>We recommend that you DO NOT attach the interrupt pin INTpin to an actual Arduino interrupt. Instead, check for messages calling <a class="el" href="class_c_a_n___i_o.html#a02724e01fa0b5d3bd6d50e00f5b4f523" title="Fetch any available messages from the MCP2515. ">CAN_IO::Fetch</a>, which will check the INTpin to see if messages are waiting to be transferred from the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> to the Arduino.</dd></dl>
</li>
<li>To send a packet, create a layout object: <div class="fragment"><div class="line"><a class="code" href="class_d_c___drive.html">DC_Drive</a> drivePacket(&lt;velocity&gt;, &lt;current&gt;);</div></div><!-- fragment --> Then call <div class="fragment"><div class="line">can.Send(drivePacket,<a class="code" href="_m_c_p2515__defs_8h.html#ae206adaf940a352305d59b0153594282">TXB0</a>);</div></div><!-- fragment --> where TXB0 specifies one of the three transmission buffers to send the message out over (alternate buffers to send messages in quicker succession). You can also use an implicit packet object: <div class="fragment"><div class="line">can.Send(<a class="code" href="class_d_c___drive.html">DC_Drive</a>(velocity, current), <a class="code" href="_m_c_p2515__defs_8h.html#ae206adaf940a352305d59b0153594282">TXB0</a>);</div></div><!-- fragment --> If you want the system to automatically select a TX buffer for you, pass the buffer TXBANY. <div class="fragment"><div class="line">can.Send(<a class="code" href="class_d_c___drive.html">DC_Drive</a>(velocity, current), <a class="code" href="_m_c_p2515__defs_8h.html#a9a0dc14d98d9b8bdab544804c39f63ac">TXBANY</a>);</div></div><!-- fragment --> /note Currently, the library does not wait for a buffer to become open before attempting to load it. If you try to send from a buffer that is currently being used, packet data may be corrupted. Use the TXBANY option to avoid this. Alternatively, you can call <code>CAN_IO::Send_Verified(&lt;packet&gt;, &lt;buffer&gt;)</code> to make sure the correct data was loaded onto the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a>.</li>
<li>Call <code><a class="el" href="class_c_a_n___i_o.html#a02724e01fa0b5d3bd6d50e00f5b4f523" title="Fetch any available messages from the MCP2515. ">CAN_IO::Fetch()</a></code> at least once per main control loop. This checks for any messages on the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> and loads them. It is recommended that this function be used rather than attaching interrupts, as interrupts have been known to cause conflicts with serial communication that results in corrupted CAN data.</li>
<li>Messages retrieved by <code><a class="el" href="class_c_a_n___i_o.html#a02724e01fa0b5d3bd6d50e00f5b4f523" title="Fetch any available messages from the MCP2515. ">CAN_IO::Fetch()</a></code> are loaded into an internal frame FIFO buffer. To get the messages on this buffer, use <div class="fragment"><div class="line"><span class="keywordflow">if</span> (can.Available()) {</div><div class="line">    <a class="code" href="struct_frame.html">Frame</a>&amp; f = can.Read();</div><div class="line">    <span class="comment">/*...*/</span></div><div class="line">}</div></div><!-- fragment --> The variable <code>f</code> is then a reference to the first frame in the buffer. You can find the packet type of this frame using f.id, which will be a hexidecimal number between 0x000 and 0x7FF.</li>
<li>Once the packet type has been identified, convert it into the appropriate layout class: <div class="fragment"><div class="line"><a class="code" href="class_d_c___drive.html">DC_Drive</a> receivedPacket(f);</div></div><!-- fragment --></li>
<li>Access the data using the layout class variables: <div class="fragment"><div class="line">receivedPacket.velocity;</div></div><!-- fragment --></li>
<li>The <a class="el" href="class_c_a_n___i_o.html" title="Class for handling CAN I/O operations using the MCP2515 CAN controller. ">CAN_IO</a> object keeps track of errors that occur in an internal state variable "errors", as well as the TEC and REC counters of the <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a>. To update these, call <a class="el" href="class_c_a_n___i_o.html#a10393f1a9f55c853bb21d74ebbc9d7ca" title="Fetch the error status of the MCP2515 over SPI and update internal variables. ">CAN_IO::FetchErrors()</a>.</li>
<li>The <a class="el" href="class_m_c_p2515.html" title="a class which acts as an interface to the MCP2515 chip. ">MCP2515</a> may occasionally enter sleep mode for random reasons. Code to detect this will be written into the <a class="el" href="class_c_a_n___i_o.html" title="Class for handling CAN I/O operations using the MCP2515 CAN controller. ">CAN_IO</a> class in a future release, but for now the check and reset procedure if this occurs must be done by you.</li>
</ol>
<h2>Example Code </h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_c_a_n___i_o_8h.html">CAN_IO.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;SPI.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">/*************************************         NOTE        ******************************************************/</span></div><div class="line"><span class="comment">/* This example code is desgined to be run on two Arduino processors connected to a common 1000 kbps </span></div><div class="line"><span class="comment">/* CAN bus via MCP2515 can controllers. Designate one arduino to be the receiver, and one to be the transmitter.</span></div><div class="line"><span class="comment">/* On the receiver, comment out the SEND block in the loop(). On the transmitter, comment out the RECEIVE block.</span></div><div class="line"><span class="comment">/****************************************************************************************************************/</span></div><div class="line"></div><div class="line"><span class="comment">// First the CAN parameters are initialized</span></div><div class="line"><span class="keyword">const</span> byte     CAN_CS      = 10;      <span class="comment">// The arduino pin to which the MCP2515 CS (chip select) input is attached</span></div><div class="line"><span class="keyword">const</span> byte     CAN_INT     = 2;       <span class="comment">// The arduino pin to which the MPC2515 INT (interrupt) pin is attached</span></div><div class="line"><span class="keyword">const</span> uint16_t CAN_BAUD_RATE = 1000;  <span class="comment">// MUST match the baud rate of the CAN bus. Setting this to 0 will enable Auto-BAUD (untested)</span></div><div class="line"><span class="keyword">const</span> byte     CAN_FREQ      = 16;    <span class="comment">// MUST BE the frequency of the oscillator you use</span></div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> previous_send_time = 0; <span class="comment">// A timing variable we define to keep </span></div><div class="line"></div><div class="line"><span class="comment">// Then the can controller object is set up using the configuration variables.</span></div><div class="line"><a class="code" href="class_c_a_n___i_o.html">CAN_IO</a> CanControl(CAN_CS,CAN_INT,CAN_BAUD_RATE,CAN_FREQ);</div><div class="line"></div><div class="line"><span class="comment">//  </span></div><div class="line"><span class="comment">//  The Arduino Setup() routine begins the SPI protocols to output received data to the COM window, Sets the applicable CAN filters,</span></div><div class="line"><span class="comment">//  and then calls the CAN_IO::Setup() routine. In this case, the CAN controller is set up to listen only for BMS State of Charge and </span></div><div class="line"><span class="comment">//  motor controller velocity data packets.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keywordtype">void</span> setup() {</div><div class="line">  <span class="comment">// Start serial here so that we can communicate with the test computer. Not necessary for CAN to work.</span></div><div class="line">  Serial.begin(9600);</div><div class="line"></div><div class="line">  <span class="comment">// Here is where we specify which packets we want to filter out, and then instruct the controler to</span></div><div class="line">  <span class="comment">// initialize using the Setup command</span></div><div class="line">  CanControl.filters.setRB0(<a class="code" href="_layouts_8h.html#a18b4061cc90be421890eb9da2b1afa98">MASK_Sxxx</a>,<a class="code" href="_layouts_8h.html#aa68aebb7a00233255330976a3f3f5832">DC_DRIVE_ID</a>, <a class="code" href="_layouts_8h.html#a3d61d13dd8174b339e37721aabcd6586">MC_VELOCITY_ID</a>); </div><div class="line">  CanControl.filters.setRB1(<a class="code" href="_layouts_8h.html#a18b4061cc90be421890eb9da2b1afa98">MASK_Sxxx</a>,0,0,0,0);</div><div class="line">  CanControl.Setup();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> loop() {</div><div class="line">  <span class="comment">/******  SEND  ********/</span></div><div class="line">  <span class="comment">// Send data over the CAN bus every 500 ms</span></div><div class="line">  <span class="keywordflow">if</span> (millis() - previous_send_time &gt; 500) <span class="comment">// Check and see whether it is time to send another packet</span></div><div class="line">  {</div><div class="line">    <span class="comment">// Send the DC_Drive packet, which controls the (velocity, current) of the Wavesculptor 22 motor controller, and let the arduino choose which TX (transmit) buffer on the MCP2515 to use</span></div><div class="line">    <span class="comment">// If all you care about is sending data, you can stop after running this command.</span></div><div class="line">    CanControl.Send(<a class="code" href="class_d_c___drive.html">DC_Drive</a>(37.5,100),<a class="code" href="_m_c_p2515__defs_8h.html#a9a0dc14d98d9b8bdab544804c39f63ac">TXBANY</a>);</div><div class="line"></div><div class="line">    <span class="comment">// To help with debugging the CAN bus, you can print out the error counters of the MCP2515. </span></div><div class="line">    <span class="comment">// Before you read these values, you need to fetch them using the FetchErrors() command, which grabs</span></div><div class="line">    <span class="comment">// status and error counter registers.</span></div><div class="line">    <span class="comment">// If you see the TEC and/or REC counters continuously incrementing, it means that your MCP2515</span></div><div class="line">    <span class="comment">// is not able to sucessfully read and/or write messages to the CAN bus. You should troubleshoot the issue</span></div><div class="line">    <span class="comment">// (See the troubleshooting guide in the documentation)</span></div><div class="line"></div><div class="line">    CanControl.FetchErrors(); <span class="comment">//Call this first to get the error data from the MCP2515</span></div><div class="line">    Serial.print(<span class="stringliteral">&quot;TEC/REC &quot;</span>);</div><div class="line">    Serial.print(CanControl.tec); Serial.print(<span class="stringliteral">&quot;, &quot;</span>);</div><div class="line">    Serial.println(CanControl.rec);</div><div class="line"></div><div class="line">    <span class="comment">// This line resets the timing variable we use to send CAN packets.</span></div><div class="line">    previous_send_time = millis();</div><div class="line">  }</div><div class="line">  <span class="comment">/****** END SEND *******/</span></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">/******* RECEIVE *******/</span></div><div class="line">  <span class="comment">// If there are any new messages, they will be loaded from the MCP2515 into an internal buffer with</span></div><div class="line">  <span class="comment">// this function call</span></div><div class="line">  CanControl.Fetch(); </div><div class="line"></div><div class="line">  <span class="comment">// Now we check to see if we fetched any messages.</span></div><div class="line">  <span class="keywordflow">if</span> (CanControl.Available())</div><div class="line">  {</div><div class="line">    <span class="comment">// Get the frame of of the buffer. Read() returns a reference to a frame object which we can then convert into a string</span></div><div class="line">    <a class="code" href="struct_frame.html">Frame</a>&amp; f = CanControl.Read();</div><div class="line"></div><div class="line">    <span class="comment">// Determine which packet type the frame is using frame.id</span></div><div class="line">    <span class="keywordflow">switch</span> (f.<a class="code" href="struct_frame.html#af0b7b5066af6657239ab3c3fe5174bd3">id</a>) {</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="_layouts_8h.html#aa68aebb7a00233255330976a3f3f5832">DC_DRIVE_ID</a>:</div><div class="line">        <a class="code" href="class_d_c___drive.html">DC_Drive</a> packet(f); <span class="comment">// Initialze a packet object using the data in the frame.</span></div><div class="line"></div><div class="line">        <span class="comment">// Print the data over serial to a test computer</span></div><div class="line">        Serial.println(<span class="stringliteral">&quot;Velocity and Current Data Received:&quot;</span>);</div><div class="line">        Serial.println(packet.velocity);</div><div class="line">        Serial.println(packet.current);</div><div class="line">        Serial.println(<span class="stringliteral">&quot;--&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">default</span>: </div><div class="line">        Serial.print(<span class="stringliteral">&quot;Unknown Packet Received with id &quot;</span>);</div><div class="line">        Serial.println(f.<a class="code" href="struct_frame.html#af0b7b5066af6657239ab3c3fe5174bd3">id</a>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="comment">/******** END RECEIVE *********/</span></div><div class="line"></div><div class="line">  <span class="comment">// Run the loop() function every 100 ms</span></div><div class="line">  delay(100);</div><div class="line">}</div></div><!-- fragment --><h2>Contact </h2>
<p>NUsolar project manager &ndash; project hyphen manager at nusolar dot org</p>
<p>Alexander Martin &ndash; a hyphen martin at u dot northwestern dot edu</p>
<h2>Licence </h2>
<p>This library is Copyright 2015 by NUsolar. The code may be used in non-commercial projects without compensation, but we would appreciate it if you let us know that you're using it.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd><h2>Documentation To-Dos </h2>
<ul>
<li>Write description of how to add a new CAN frame</li>
<li>Example snippets for each major function.</li>
<li><a class="el" href="struct_c_a_n_filter_opt.html" title="A special struct to hold filter info for the MCP2515 RX buffers. ">CANFilterOpt</a> class description</li>
<li>Detailed descriptions for each <a class="el" href="class_c_a_n___i_o.html" title="Class for handling CAN I/O operations using the MCP2515 CAN controller. ">CAN_IO</a> callable function.</li>
</ul>
</dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
